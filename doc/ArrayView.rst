.. role:: cpp(code)

    :language: cpp

ArrayView
=========

The object :cpp:`il::ArrayView<T>` should be thought as a wrapper around the
pair :cpp:`(const T* p, int n)` which is often seen in C programs. It is a view
for an array of type :cpp:`T`. Those elements must be in contiguous
locations of the memory. It is the responsability of the programmer that the
underlying memory remains valid during the lifetime of the object. As the name
suggests, it only allow read access to the elements of the array. For those who
need read and write access to the underlying memory, the object you are looking
for is :cpp:`il::ArrayEdit<T>`.

Overview
--------

Let's start with a simple example. The following code computes the sum of the
elements of an array view:

.. code-block:: cpp

    #include <il/ArrayView.h>

    double sum(il::ArrayView<double> v) {
      double sum = 0.0;

      for (il::int_t i = 0; i < v.size(); ++i) {
        sum += v[i];
      }

      return sum;
    }

From this small code, we can infer that:

- :cpp:`il::ArrayView<T>` are passed by value because they are cheap to copy.
  Creating a new view from another one is done by copying a pointer and an
  integer. Unlike :cpp:`il::Array<T>` which owns its memory, copying an array
  view does not copy any of the object it gives access to.
- Much like a regular array, an array view has a size that can be accessed
  through the :cpp:`size()` method. Read access to the element of index :cpp:`i`
  is available with the bracket operator :cpp:`v[i]`. We use an index of type
  :cpp:`il::int_t` which is an alias for a natural sized signed integer
  (a 32-bit signed integer on 32-bit platforms and a 64-bit
  signed integer on 64-platforms). Much like the :cpp:`il::Array<T>` container,
  bound checking is available in debug mode and is turned off in release mode
  for performance reason.
- In terms of performance, if you look at the code generated by most compilers
  in release mode,
  you'll find that some vector instructions are generated. This can lead to
  code that is 8 times faster than the serial code. This optimization
  is possible because the elements of the array view are contiguous in memory.
  We say that the physical stride of the array is 1.

Moreover, an array view provide all the methods in the standard library that
allow us to write the previous code with the C++11 mechanism:

.. code-block:: cpp

    #include <il/ArrayView.h>

    double sum(il::ArrayView<double> v) {
      double sum = 0.0;
      for (double x : v) { sum += x; }
      return sum;
    }

Use cases
---------

An array view can be used in different situations.

- **It can be used to pack a pointer and a size into a single object**.
  This is very useful to benefit from bounds checking in debug mode. For
  instance, if your API impose you to
  get a pointer to an array with the size of the array it points to, it is a
  good idea to pack this information into an array view.

  .. code-block:: cpp

    #include <il/ArrayView.h>

    bool contains_zero(const double* p, int n) {
      const il::ArrayView<double> v{p, n};
      bool ans = false;

      for (il::int_t i = 0; i < v.size(); ++i) {
        if (v[i] == 0.0) {
          ans = true;
        }
      }

      return ans;
    }

  In release mode, there is no performance penalty in using an array view
  instead of a raw pointer in a loop and you get the benefit of bounds checking
  in debug mode.


- **It can be used to access parts of an array**. An array view can be used to
  access some parts of an array. for instance, suppose that the function
  :cpp:`sum` above is available to you and you want to know if the first
  half of an array has elements whose sum is larger than the second part. This
  could be done with the following code:

  .. code-block:: cpp

    #include <il/Array.h>
    #include <il/ArrayView.h>

    double sum(il::ArrayView<double> v);

    bool isFirstHalfLarger(const il::Array<double>& a) {
      const il::int_t n = a.size();

      const il::ArrayView<double> v0 = a.view(il::Range{0, n / 2});
      const il::ArrayView<double> v1 = a.view(il::Range{n / 2, n});

      return sum(v0) > sum(v1);
    }

  One can also generate array views from arrays of larger dimensions. For
  instance, given a 2 dimension array in column major order, the following code
  returns the column whose sum is the largest one:

  .. code-block:: cpp

    #include <il/Array2D.h>
    #include <il/ArrayView.h>

    double sum(il::ArrayView<double> v);

    il::int_t largestColumn(const il::Array2D<double>& A) {
      const il::int_t n0 = A.size(0);

      double maximum = -std::numeric_limits<double>::max();
      il::int_t i1_max = -1;

      for (il::int_t i1 = 0; i1 < A.size(1); ++i) {
        const il::ArrayView<double> v = A.view(il::Range{0, n0}, i1);
        const double value = sum(v);
        if (value >= maximum) {
          maximum = value;
          i1_max = i1;
        }
      }

      return i1_max;
    }

  Bare in mind that the elements of an array view should be contiguous in
  memory. As a consequence, it is not possible to create the array view of a row
  for a :cpp:`il::Array2D<double>`.

Documentation
-------------

My method
